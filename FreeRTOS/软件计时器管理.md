---
sort: 5
---

# 软件计时器管理

## 5.1 简介与范围

软件计时器被用来在"未来的一段时间"或"周期性以固定的频率"调度函数执行。由软件计时器执行的函数被称为软件计时器回调函数。

软件计时器被FreeRTOS内核实现，且由FreeRTOS内核控制，它不需要硬件支持，也与硬件计时器或硬件计数器无关。

```note
根据FreeRTOS使用创新的设计来确保最大效率的理念，除了软件计时器回调函数正在执行的时间外，软件计时器不占用任何处理时间。
```

软件计时器功能是可选的，可以通过以下操作来让你的工程包含它：

1. 让你的工程包含FreeRTOS源文件`FreeRTOS/Source/time.c`
2. 在`FreeRTOSConfig.h`中将`configUSE_TIMERS`设为1

### 范围

本章旨在让读者理解：

- 软件计时器相对于任务的特性
- RTOS守护任务
- 计时器命令队列
- 一次性软件计时器与周期性软件计时器的区别
- 怎样去创建、启动、重置、修改软件计时器的周期

## 5.2 软件计时器回调函数

软件计时器回调函数被实现为C函数，它的唯一特别之处为它的函数原型，它必须返回`void`，并将软件计时器句柄作为唯一参数。清单72展示了软件定时器的回调函数原型。


```note
函数清单72：软件定时器回调函数原型

***void ATimerCallback(TimerHandle_t xTimer);***
```

软件计时器回调函数会从函数开头执行到函数结尾，并以正常方式退出。函数应该很快结束，绝对不能进入阻塞状态。

```danger

如我们所见，软件计时器回调函数在FreeRTOS调度器启动时自动创建，在任务的上下文中执行。因此，软件计时器回调函数绝对不能调用能够使任务进入阻塞状态的FreeRTOS API函数。
可以调用类似xQueueReceive()的函数，但函数的xTickToWait()参数(指定函数的阻塞时间)值必须设置为零。
不可以调用类似vTaskDelay()的函数，因为调用vTaskDelay()总会使任务进入阻塞状态。

```

## 5.3 软件计时器的属性和状态

### 软件计时器周期

一个软件计时器的“周期(period)”，指的是从软件计时器启动，到回调函数被调用之间的时间间隔。

### one-shot计时器与auto-reload计时器

这是两种类型的计时器：

1. one-shot计时器
   one-shot计时器一旦启动，它的回调函数仅会执行一次。one-shot计时器能够被手动重启，但它不能自己重启自己。
2. auto-reload计时器
   auto-reload计时器一旦启动，它每次到了预定的时间后会就重新启动，从而定期执行回调函数。
   
图38展示了one-shot计时器和auto-reload计时器行为的不同，垂直的虚线代表每次滴答中断发生的时间。

![figure38](../assets/images/figure38.png)

**图38： one-shot计时器和auto-reload计时器行为区别**

参见图38：

- Timer1

Timer1是一个one-shot计时器，它的周期为6个滴答中断，它在t1时刻启动，所以它的回调函数会在6个滴答中断，也就是t7时刻执行。因为Timer1是一个one-shot计时器，所以它的回调函数不会被再次执行。

- Timer2

Timer2是一个auto-reload计时器，它的周期为5个抵达中断，它在t1时刻启动，所以它的回调函数会每隔5个滴答中断执行一次，在图38中，这个时刻为t6,t11与t16。

### 软件计时器状态

一个软件计时器可以为下列两种状态之一：

- 休眠态(Dormant)

存在处于休眠状态的软件计时器，可以通过它的句柄被引用，但因为没有运行，所以它的回调函数将不会执行。

- 运行态(Running)

一个处于运行状态的软件计时器，从它**进入运行状态**或**最后一次重置软件计时器**开始，当经过了它的周期时间后，就会执行它的回调函数。

图39和图40分别展示了one-shot计时器和auto-reload计时器，在休眠态和运行态之间可能发生转换的情况。区别两个流程图的关键是，在计时器过期后进入的状态。auto-reload计时器执行它的回调函数然后重新进入运行态，one-shot计时器则执行回调函数之后进入休眠态。

xTimerDelete()API函数会删除计时器。计时器无论处于什么状态都可以被删除。

![figure39](../assets/images/figure39.png){:height="70%" width="70%"}

**图39： auto-reload软件计时器状态与切换**

![figure40](../assets/images/figure40.png){:height="65%" width="65%"}

**图40： one-shot软件计时器状态与切换**

## 5.4 软件计时器上下文

### RTOS守护(计时器服务)任务

所有的软件计时器回调函数，都在同一个RTOS守护(或称为计时器服务)任务的上下文中执行。

```note
该任务以前被叫做软件计时器服务任务(timer service task)，因为它最初只被用来执行软件计时器回调函数。现在同样的任务有了其他的作用，所以现在以更通用的"RTOS守护任务(RTOS daemon task)"命名。
```

这个守护服务是一个标准FreeRTOS任务，它在调度器启动时自动创建。它的优先级和栈大小分别由编译期常量`configTIMER_TASK_PRIORITY`与`config_TIMER_STACK_DEPTH`控制。
两个常量都被定义在`FreeRTOSConfig.h`中。

在软件计时器回调函数中，一定不能调用能够使任务进入阻塞态的FreeRTOS API函数，因为这样会使守护任务进入阻塞状态。

### 计时器命令队列

软件计时器API函数将“命令”从“调用该API的任务”发送至“守护任务”的“计时器命令队列”。它展示于图41。前面说的“命令”包括启动一个计时器、停止一个计时器、重置一个计时器。

计时器命令队列是一个标准FreeRTOS队列，它在调度器启动时自动创建。它的队列长度由编译期常量`configTIMER_QUEUE_LENGTH`设置，该常量定义在`FreeRTOSConfig.h`中。

![figure41](../assets/images/figure41.png){:height="70%" width="70%"}

**图41： 软件计时器API函数使用计时器命令队列与RTOS守护任务通信**

### 守护任务调度

守护任务调度类似于其他的FreeRTOS任务调度，如果它在可执行任务中拥有最高优先级，那么它仅会执行任务，或者执行计时器回调函数。图42与图43演示了`configTIMER_TASK_PRIORITY`如何影响执行模式。

图42展示了守护任务优先级低于调用xTimerStart()API函数任务的优先级时的执行模式。

![figure42](../assets/images/figure42.png)

**图42： 守护任务优先级低于调用xTimerStart()API函数任务的优先级时的执行模式**

参见图42，Task1的优先级要高于守护任务，守护任务的优先级要高于空闲任务。

1. t1时刻
   
   Task1在运行态，守护任务在阻塞态。
   
   守护任务将会在有命令进入命令队列时退出阻塞状态，执行命令，而如果软件计时器到期了，则将会执行软件计时器回调函数。

2. t2时刻
   
   Task1调用xTimerStart()。
   
   xTimerStart()发送命令到计时器命令队列，造成守护任务退出阻塞态。但因为Task1的优先级高于守护任务，所以守护任务不会抢占Task1。
   
   Task1一直处于运行态，而守护任务从阻塞态进入了准备态。

3. t3时刻
   
   Task1执行完成了xTimerStart()API函数。Task1从xTimerStart()函数的开头执行到函数的结尾，没有离开运行态。

4. t4时刻
   
   Task1调用了某个API函数导致自身进入了阻塞态，此时守护认为称为准备态中优先级最高优先级的任务，所以调度器会使守护任务进入运行态。之后守护任务会开始执行Task1发送到命令队列的命令。

```note
软件计时器时间是从发送"启动一个计时器"到命令队列开始计算，而不是从命令队列收到"启动一个计时器"命令开始计算。
```
5. t5时刻
   
   守护任务执行完成了Task1发送的命令，然后尝试从命令队列中获取更多数据，但是命令队列此时为空，所以守护任务会重新进入阻塞态。之后守护任务仍会因为计时器命令队列传入命令，或计时器到期重新进入准备态。
   
   此时空闲任务成为准备态任务中最高优先级的任务，所以调度器会使空闲任务进入运行态。

图43展示了类似于图42的情况，唯一的区别是调用xTimerStart()的任务优先级低于守护任务。

![figure43](../assets/images/figure43.png)

**图43： 调用xTimerStart()API函数任务的优先级低于守护任务优先级时的执行模式**

参见图43，守护任务的优先级高于Task1优先级，Task1优先级高于idle任务优先级。

1. t1时刻
   
   如上，Task1在运行态，守护任务在阻塞态。
   
2. t2时刻
   
   Task1调用了xTimerStart()。
   
   xTimerStart()发送了一个命令到计时器命令队列，使得守护任务退出阻塞态。由于守护任务的优先级高于Task1，所以调度器会选择守护任务进入运行态。
   
   Task1在执行xTimerStart()后被守护任务抢占，所以现在进入了准备态。
   
   守护任务执行Task1发送到计时器命令队列中的命令。

3. t3时刻
   
   守护任务将来自Task1的命令执行完毕，然后尝试从命令队列中获取更多数据，但是命令队列此时为空，所以守护任务会重新进入阻塞态。
   
   此时Task1成为准备态任务中最高优先级的任务，所以调度器会使Task1进入运行态。

4. t4时刻
   
   Task1在执行完毕xTimerStart()函数之间就被守护任务抢占，所以在Task1重新进入重新运行态时从被抢占处返回。

5. t5时刻
   
   Task1调用了某个API函数进入了阻塞态，此时空闲任务成为准备态任务中最高优先级的任务，所以调度器会使空闲任务进入运行态。 

在图42的场景中展示了：Task1发送一个命令到计时器命令队列与守护任务接收与处理任务的时间间隔。
在图43的场景中展示了：在Task1从发送命令的函数返回之前，守护任务接收与处理来自Task1的命令。

命令发送至计时器命令队列会带一个时间戳。这个时间戳被用来记录从应用任务发送命令，到被守护任务处理所经过的时间。
例如，发送"启动一个周期为10滴答的计时器"的命令，时间戳会用来确保发送命令后的10滴答执行回调，而不是被守护任务处理该命令后的10滴答执行回调。

## 5.5 创建和启动软件计时器

### xTimerCreate()API函数

```warning

FreeRTOS v9.0.0也包含了xTimerCreateStatic()函数，它会在编译期静态分配内存。

```

软件计时器必须在其被使用前显式创建。